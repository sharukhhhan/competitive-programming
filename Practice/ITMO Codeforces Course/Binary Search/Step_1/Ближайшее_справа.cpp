// C. Ближайшее справа
// ограничение по времени на тест2 секунды
// ограничение по памяти на тест512 мегабайт
// вводстандартный ввод
// выводстандартный вывод
// Дан массив из n
//  чисел, отсортированный по неубыванию, и k
//  запросов. Для каждого запроса выведите минимальный индекс элемента массива, не меньшего данного.

// Входные данные
// В первой строке входных данных содержатся числа n
//  и k
//  (0<n,k≤105
// ) — длина массива и число запросов. Во второй строке содержатся n
//  элементов массива, отсортированного по неубыванию. В третьей строке содержатся k
//  запросов. Все элементы массива и запросы — целые числа, каждое из которых по модулю не превосходит 2⋅109
//  .

// Выходные данные
// Для каждого из k
//  запросов выведите минимальный индекс элемента массива, не меньшего данного. Если таких нет, выведите n+1
// .

// Пример
// входные данныеСкопировать
// 5 5
// 3 3 5 8 9
// 2 4 8 1 10
// выходные данныеСкопировать
// 1
// 3
// 4
// 1
// 6

#include <bits/stdc++.h>

using namespace std;

int left_binary_search(vector<int>& a, int x) {
    int l = -1;
    int r = a.size();
    while (r - l > 1) {
        int mid = (r + l) / 2;
        if (a[mid] <= x) {
            l = mid;
        } else {
            r = mid;
        }
    }

    return l;
}

int right_binary_search(vector<int>& a, int x) {
    int l = -1;
    int r = a.size();
    while (r - l > 1) {
        int mid = (l + r) / 2;
        if (a[mid] < x) {
            l = mid;
        } else {
            r = mid;
        }
    }

    return r;
}

int main() {
    int n, k;
    cin >> n >> k;
    vector<int> a(n), q(k);
    for (int i = 0; i < n; i++) cin >> a[i];
    while(k--) {
        int x;
        cin >> x;
        cout << right_binary_search(a, x) + 1 << '\n';
    }

}